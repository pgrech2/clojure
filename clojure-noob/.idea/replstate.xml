<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1470677060876">{:repl-history {:ide [], :local [&quot;(def new_map {:name {:first \&quot;paul\&quot; :last \&quot;grech\&quot;}} \&quot;Default\&quot;)&quot; &quot;new_map&quot; &quot;(get new_map :name)&quot; &quot;(get-in new_map [:name :first])&quot; &quot;(get-in new_map [:name :first_name])&quot; &quot;(get-in new_map [:name :middle_name] \&quot;default\&quot;)&quot; &quot;#{“kurt vonnegut” 20 :icicle}&quot; &quot;#{\&quot;kurt vonnegut\&quot; 20 :icicle}&quot; &quot;(def set1 #{20 :icicle \&quot;kurt vonnegut\&quot;})&quot; &quot;(conj set1 20)&quot; &quot;(conj set1 21)&quot; &quot;(def set2 (conj set1 21))&quot; &quot;(def set1 (conj set1 25))&quot; &quot;set1&quot; &quot;set2&quot; &quot;(hash-set [1 1 23 2 3 ])&quot; &quot;(\n  set [1 1 23 2 3 ])&quot; &quot;(set [3 3 4 4])&quot; &quot;(set [1 1 2 3 2 3 ])&quot; &quot;(conj #{:b :a} :a)&quot; &quot;(conj #{:b :a} :b)&quot; &quot;(conj #{:b :a} :B)&quot; &quot;test&quot; &quot;(+ 1 2 3)&quot; &quot;(* 4 5 6)&quot; &quot;(+ 2 3)&quot; &quot;-paul_func&quot; &quot;(-paul_func)&quot; &quot;(-train)&quot; &quot;(-main)&quot; &quot;(+ 1 (* 2 3) 4)&quot; &quot;(+ 1 (| 2) 3)&quot; &quot;(+ 1 (* | 2) 3 4)&quot; &quot;(+ 1 (* | 2 3) 4)&quot; &quot;(+ 1 (* |2 3) 4)&quot; &quot;(+ 1 (* | 2 3 4))&quot; &quot;(+ 1 (* 2 3 4))&quot; &quot;1&quot; &quot;\&quot;a string\&quot;&quot; &quot;[\&quot;a\&quot; \&quot;vector\&quot; \&quot;of\&quot; \&quot;strings\&quot;]&quot; &quot;(+ 1 2)&quot; &quot;(* 4 5)&quot; &quot;(str \&quot;hi, my name\&quot; \&quot;is paul\&quot; \&quot;what is yours\&quot;)&quot; &quot;(str \&quot;hi, my name \&quot; \&quot;is paul \&quot; \&quot;what is yours\&quot;)&quot; &quot;(if TRUE \&quot;this is true\&quot; \&quot;this is false\&quot;)&quot; &quot;(if TRUE\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if true\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if false?\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if false\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if (1 == 1)\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if (= 1 1)\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if (= 1 2)\n  \&quot;this is true\&quot;\n  \&quot;this is false\&quot;)&quot; &quot;(if true\n  (do (printl \&quot;this is true \&quot; \&quot;and truth comes with this\&quot;))\n  (do (printl \&quot;this is false\&quot; \&quot;and false comes with nothing\&quot;)))&quot; &quot;(if true\n  (do (printl \&quot;this is true\&quot;) \&quot;the truth\&quot;)\n  (do (printl \&quot;this is false\&quot;) \&quot;falsify\&quot;))&quot; &quot;(if true\n  (do (printl \&quot;this is true\&quot;) \n      \&quot;the truth\&quot;)\n  (do (printl \&quot;this is false\&quot;) \n      \&quot;falsify\&quot;)\n  )&quot; &quot;(if true\n  (do (println \&quot;this is true\&quot;) \n      \&quot;the truth\&quot;)\n  (do (println \&quot;this is false\&quot;) \n      \&quot;falsify\&quot;)\n  )&quot; &quot;(when true\n  (println \&quot;here is a when\&quot;)\n  \&quot;and another expression\&quot;)&quot; &quot;(when false\n  (println \&quot;here is a when\&quot;)\n  \&quot;and another expression\&quot;)&quot; &quot;(nil? 1)&quot; &quot;(nil? nil)&quot; &quot;(if \&quot;hello ther\&quot;\n  \&quot;true\&quot;)&quot; &quot;(if \&quot;hello ther\&quot;\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(if 2\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(if nil\n  \&quot;true\&quot;\n  \&quot;false\&quot;)&quot; &quot;(= 1 1)&quot; &quot;(= 1 2)&quot; &quot;(= \&quot;hello\&quot; \&quot;there\&quot;)&quot; &quot;(= \&quot;hello\&quot; \&quot;hello\&quot;)&quot; &quot;(or nil)&quot; &quot;(or true nil :a :b)&quot; &quot;(or false :a :b)&quot; &quot;(or false nil&quot; &quot;(or false nil :a :b)&quot; &quot;(or true nil)&quot; &quot;(or false true)&quot; &quot;(or false false)&quot; &quot;(or false nil)&quot; &quot;(or :a :b)&quot; &quot;(or :a :a)&quot; &quot;(or :b :a)&quot; &quot;(or false :a nil)&quot; &quot;(or (= 1 0) a)&quot; &quot;(or (= 1 0) :a)&quot; &quot;(or (= 1 1) :a)&quot; &quot;(and :a :b)&quot; &quot;(and nil :b)&quot; &quot;(def var1 [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot;])&quot; &quot;var1&quot; &quot;93&quot; &quot;1,2&quot; &quot;1.2&quot; &quot;1/5&quot; &quot;(/ 1 5)&quot; &quot;(-main2)&quot; &quot;(conains #{:a :b} :a)&quot; &quot;(conains? #{:a :b} :a)&quot; &quot;(contains? #{:a :b} :a)&quot; &quot;(contains? #{1 2} 1)&quot; &quot;(contains? #{1 2} 0\n           )&quot; &quot;(contains? {nil} nil)&quot; &quot;(contains? #{nil} nil)&quot;], :remote []}}</component>
</project>